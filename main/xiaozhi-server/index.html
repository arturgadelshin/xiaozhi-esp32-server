<!DOCTYPE html>
<html lang="ru-RU">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тестовая страница сервера XiaoZhi</title>
    <style>
        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 10px 20px 10px 20px;
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .section {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 8px;
            background-color: #f9f9f9;
        }

        .section h2 {
            margin-top: 0;
            color: #444;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 0;
        }

        .section h2 .toggle-button {
            margin-left: auto;
            padding: 4px 12px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
            height: 28px;
            line-height: 20px;
        }

        .device-info {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-left: 20px;
            padding: 0 15px;
            background-color: #f9f9f9;
            border-radius: 4px;
            height: 28px;
            line-height: 28px;
        }

        .device-info span {
            color: #666;
            font-size: 13px;
        }

        .device-info strong {
            color: #333;
            font-weight: 500;
        }

        .config-panel {
            display: none;
            transition: all 0.3s ease;
            margin-top: 5px;
            padding: 5px 0;
        }

        .config-panel.expanded {
            display: block;
        }

        .control-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            background-color: #4285f4;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #3367d6;
        }

        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        #serverUrl,
        #otaUrl {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .message-input {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        #messageInput {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        #nfcCardId {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .conversation {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background-color: white;
            flex: 1;
            margin-right: 10px;
        }

        .message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            max-width: 80%;
        }

        .user {
            background-color: #e2f2ff;
            margin-left: auto;
            margin-right: 10px;
            text-align: right;
        }

        .server {
            background-color: #f0f0f0;
            margin-right: auto;
            margin-left: 10px;
        }

        .status {
            color: #666;
            font-style: italic;
            font-size: 14px;
            margin: 0;
            padding: 0;
        }

        .audio-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .audio-visualizer {
            height: 60px;
            width: 100%;
            margin-top: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #fafafa;
        }

        .record-button {
            background-color: #db4437;
        }

        .record-button:hover {
            background-color: #c53929;
        }

        .record-button.recording {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                background-color: #db4437;
            }

            50% {
                background-color: #ff6659;
            }

            100% {
                background-color: #db4437;
            }
        }

        #logContainer {
            margin-top: 0;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            font-family: monospace;
            height: 300px;
            overflow-y: auto;
            flex: 1;
            margin-left: 10px;
        }

        .log-entry {
            margin: 5px 0;
            font-size: 12px;
        }

        .log-info {
            color: #333;
        }

        .log-error {
            color: #db4437;
        }

        .log-success {
            color: #0f9d58;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }

            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        .script-status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .script-loaded {
            background-color: #0f9d58;
        }

        .script-loading {
            background-color: #f4b400;
        }

        .script-error {
            background-color: #db4437;
        }

        .script-list {
            margin: 10px 0;
            padding: 10px;
            background-color: #f9f9f9;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
        }

        #scriptStatus.success {
            background-color: #e6f4ea;
            color: #0f9d58;
            border-left: 4px solid #0f9d58;
        }

        #scriptStatus.error {
            background-color: #fce8e6;
            color: #db4437;
            border-left: 4px solid #db4437;
        }

        #scriptStatus.warning {
            background-color: #fef7e0;
            color: #f4b400;
            border-left: 4px solid #f4b400;
        }

        /* Стили вкладок */
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #e0e0e0;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 16px;
            color: #666;
            position: relative;
            transition: all 0.3s ease;
        }

        .tab:hover {
            color: #4285f4;
        }

        .tab.active {
            color: #4285f4;
            font-weight: bold;
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: #4285f4;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .flex-container {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        .config-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            width: 100%;
        }

        .config-item label {
            width: 100px;
            text-align: right;
            margin-right: 10px;
            color: #666;
        }

        .config-item input {
            flex-grow: 1;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        .connection-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            width: 100%;
        }

        .connection-controls input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            min-width: 200px;
        }

        .connection-controls button {
            white-space: nowrap;
            padding: 8px 15px;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-left: 20px;
            padding: 0 15px;
            background-color: #f9f9f9;
            border-radius: 4px;
            height: 28px;
            line-height: 28px;
        }

        .connection-status span {
            color: #666;
            font-size: 13px;
        }

        .connection-status .status {
            color: #333;
            font-weight: 500;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Тестовая страница сервера XiaoZhi</h1>

        <div id="scriptStatus" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);">
            Загрузка библиотеки Opus...</div>

        <!-- Панель настроек -->
        <div class="section">
            <h2>
                Настройки устройства
                <span class="device-info">
                    <span>MAC: <strong id="displayMac"></strong></span>
                    <span>Клиент: <strong id="displayClient">web_test_client</strong></span>
                </span>
                <button class="toggle-button" id="toggleConfig">Редактировать</button>
            </h2>
            <div class="config-panel" id="configPanel">
                <div class="control-panel">
                    <div class="config-item">
                        <label for="deviceMac">MAC устройства:</label>
                        <input type="text" id="deviceMac" placeholder="MAC-адрес устройства">
                    </div>
                    <div class="config-item">
                        <label for="deviceName">Имя устройства:</label>
                        <input type="text" id="deviceName" value="Тестовое устройство (Web)" placeholder="Имя устройства">
                    </div>
                    <div class="config-item">
                        <label for="clientId">ID клиента:</label>
                        <input type="text" id="clientId" value="web_test_client" placeholder="ID клиента">
                    </div>
                    <div class="config-item">
                        <label for="token">Токен авторизации:</label>
                        <input type="text" id="token" value="your-token1" placeholder="Токен авторизации">
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>
                Состояние подключения
                <span class="connection-status">
                    <span>OTA: <span id="otaStatus" class="status">OTA не подключено</span></span>
                    <span>WS: <span id="connectionStatus" class="status">WS не подключено</span></span>
                </span>
            </h2>
            <div class="connection-controls">
                <input type="text" id="otaUrl" value="http://127.0.0.1:8002/xiaozhi/ota/"
                    placeholder="Адрес OTA-сервера, например: http://127.0.0.1:8002/xiaozhi/ota/" />
                <input type="text" id="serverUrl" value="ws://127.0.0.1:8000/xiaozhi/v1/"
                    placeholder="Адрес WebSocket-сервера, например: ws://127.0.0.1:8000/xiaozhi/v1/" />
                <button id="connectButton">Подключиться</button>
                <button id="authTestButton">Проверить авторизацию</button>
            </div>
        </div>

        <div class="section">
            <div class="tabs">
                <button class="tab active" data-tab="text">Текстовое сообщение</button>
                <button class="tab" data-tab="voice">Голосовое сообщение</button>
            </div>

            <div class="tab-content active" id="textTab">
                <div class="message-input">
                    <input type="text" id="messageInput" placeholder="Введите сообщение..." disabled>
                    <button id="sendTextButton" disabled>Отправить</button>
                </div>
            </div>

            <div class="tab-content" id="voiceTab">
                <div class="audio-controls">
                    <button id="recordButton" class="record-button" disabled>Начать запись</button>
                </div>
                <canvas id="audioVisualizer" class="audio-visualizer"></canvas>
            </div>
        </div>

        <div class="section">
            <h2>Журнал диалога</h2>
            <div class="flex-container">
                <div id="conversation" class="conversation"></div>
                <div id="logContainer">
                    <div class="log-entry log-info">Готово. Подключитесь к серверу для начала теста...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Библиотека Opus -->
    <script src="libopus.js"></script>

    <script>
        // Проверка загрузки библиотеки Opus
        function checkOpusLoaded() {
            try {
                if (typeof Module === 'undefined') {
                    throw new Error('Библиотека Opus не загружена, объект Module не найден');
                }

                if (typeof Module.instance !== 'undefined' && typeof Module.instance._opus_decoder_get_size === 'function') {
                    window.ModuleInstance = Module.instance;
                    log('Библиотека Opus загружена (используется Module.instance)', 'success');
                    updateScriptStatus('Библиотека Opus загружена', 'success');

                    const statusElement = document.getElementById('scriptStatus');
                    if (statusElement) statusElement.style.display = 'none';
                    return;
                }

                if (typeof Module._opus_decoder_get_size === 'function') {
                    window.ModuleInstance = Module;
                    log('Библиотека Opus загружена (используется глобальный Module)', 'success');
                    updateScriptStatus('Библиотека Opus загружена', 'success');

                    const statusElement = document.getElementById('scriptStatus');
                    if (statusElement) statusElement.style.display = 'none';
                    return;
                }

                throw new Error('Функции декодирования Opus не найдены, возможно, структура Module некорректна');
            } catch (err) {
                log(`Ошибка загрузки библиотеки Opus: ${err.message}`, 'error');
                updateScriptStatus('Ошибка загрузки библиотеки Opus', 'error');
            }
        }

        function updateScriptStatus(message, type) {
            const statusElement = document.getElementById('scriptStatus');
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.className = `script-status ${type}`;
                statusElement.style.display = 'block';
                statusElement.style.width = 'auto';
            }
        }

        // Глобальные переменные
        let websocket = null;
        let mediaRecorder = null;
        let audioContext = null;
        let analyser = null;
        let audioChunks = [];
        let isRecording = false;
        let visualizerCanvas = document.getElementById('audioVisualizer');
        let visualizerContext = visualizerCanvas.getContext('2d');
        let audioQueue = [];
        let isPlaying = false;
        let opusDecoder = null;
        let visualizationRequest = null;

        let audioBuffers = [];
        let totalAudioSize = 0;
        let audioBufferQueue = [];
        let isAudioBuffering = false;
        let isAudioPlaying = false;
        const BUFFER_THRESHOLD = 3;
        const MIN_AUDIO_DURATION = 0.1;
        let streamingContext = null;
        const SAMPLE_RATE = 16000;
        const CHANNELS = 1;
        const FRAME_SIZE = 960;

        // Элементы DOM
        const connectButton = document.getElementById('connectButton');
        const serverUrlInput = document.getElementById('serverUrl');
        const connectionStatus = document.getElementById('connectionStatus');
        const messageInput = document.getElementById('messageInput');
        const sendTextButton = document.getElementById('sendTextButton');
        const recordButton = document.getElementById('recordButton');
        const conversationDiv = document.getElementById('conversation');
        const logContainer = document.getElementById('logContainer');

        // Логирование
        function log(message, type = 'info') {
            const lines = message.split('\n');
            const now = new Date();
            const timestamp = `[${now.toLocaleTimeString()}.${now.getMilliseconds().toString().padStart(3, '0')}] `;
            lines.forEach((line, index) => {
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                const prefix = index === 0 ? timestamp : ' '.repeat(timestamp.length);
                logEntry.textContent = `${prefix}${line}`;
                logEntry.style.whiteSpace = 'pre';
                if (type === 'error') logEntry.style.color = 'red';
                else if (type === 'warning') logEntry.style.color = 'orange';
                else if (type === 'success') logEntry.style.color = 'green';
                logContainer.appendChild(logEntry);
            });
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        function initVisualizer() {
            visualizerCanvas.width = visualizerCanvas.clientWidth;
            visualizerCanvas.height = visualizerCanvas.clientHeight;
            visualizerContext.fillStyle = '#fafafa';
            visualizerContext.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
        }

        function drawVisualizer(dataArray) {
            visualizationRequest = requestAnimationFrame(() => drawVisualizer(dataArray));
            if (!isRecording) return;
            analyser.getByteFrequencyData(dataArray);
            visualizerContext.fillStyle = '#fafafa';
            visualizerContext.fillRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
            const barWidth = (visualizerCanvas.width / dataArray.length) * 2.5;
            let barHeight;
            let x = 0;
            for (let i = 0; i < dataArray.length; i++) {
                barHeight = dataArray[i] / 2;
                visualizerContext.fillStyle = `rgb(${barHeight + 100}, 50, 50)`;
                visualizerContext.fillRect(x, visualizerCanvas.height - barHeight, barWidth, barHeight);
                x += barWidth + 1;
            }
        }

        function addMessage(text, isUser = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'server'}`;
            messageDiv.textContent = text;
            conversationDiv.appendChild(messageDiv);
            conversationDiv.scrollTop = conversationDiv.scrollHeight;
        }

        function startAudioBuffering() {
            if (isAudioBuffering || isAudioPlaying) return;
            isAudioBuffering = true;
            log("Начало буферизации аудио...", 'info');
            initOpusDecoder().catch(error => {
                log(`Ошибка предварительной инициализации декодера Opus: ${error.message}`, 'warning');
            });

            setTimeout(() => {
                if (isAudioBuffering && audioBufferQueue.length > 0) {
                    log(`Таймаут буферизации, пакетов: ${audioBufferQueue.length}, начинаем воспроизведение`, 'info');
                    playBufferedAudio();
                }
            }, 300);

            const bufferCheckInterval = setInterval(() => {
                if (!isAudioBuffering) {
                    clearInterval(bufferCheckInterval);
                    return;
                }
                if (audioBufferQueue.length >= BUFFER_THRESHOLD) {
                    clearInterval(bufferCheckInterval);
                    log(`Буферизация: ${audioBufferQueue.length} пакетов, начинаем воспроизведение`, 'info');
                    playBufferedAudio();
                }
            }, 50);
        }

        function playBufferedAudio() {
            if (isAudioPlaying || audioBufferQueue.length === 0) return;
            isAudioPlaying = true;
            isAudioBuffering = false;

            const initDecoderAndPlay = async () => {
                try {
                    if (!audioContext) {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
                        log('Аудио-контекст создан, частота: ' + SAMPLE_RATE + ' Гц', 'debug');
                    }

                    if (!opusDecoder) {
                        log('Инициализация декодера Opus...', 'info');
                        try {
                            opusDecoder = await initOpusDecoder();
                            if (!opusDecoder) throw new Error('Инициализация декодера не удалась');
                            log('Декодер Opus инициализирован', 'success');
                        } catch (error) {
                            log('Ошибка инициализации декодера Opus: ' + error.message, 'error');
                            isAudioPlaying = false;
                            return;
                        }
                    }

                    if (!streamingContext) {
                        streamingContext = {
                            queue: [],
                            playing: false,
                            endOfStream: false,
                            source: null,
                            totalSamples: 0,
                            lastPlayTime: 0,

                            decodeOpusFrames: async function (opusFrames) {
                                if (!opusDecoder) {
                                    log('Декодер Opus не инициализирован', 'error');
                                    return;
                                }
                                let decodedSamples = [];
                                for (const frame of opusFrames) {
                                    try {
                                        const frameData = opusDecoder.decode(frame);
                                        if (frameData && frameData.length > 0) {
                                            const floatData = convertInt16ToFloat32(frameData);
                                            for (let i = 0; i < floatData.length; i++) {
                                                decodedSamples.push(floatData[i]);
                                            }
                                        }
                                    } catch (error) {
                                        log("Ошибка декодирования Opus: " + error.message, 'error');
                                    }
                                }
                                if (decodedSamples.length > 0) {
                                    for (let i = 0; i < decodedSamples.length; i++) {
                                        this.queue.push(decodedSamples[i]);
                                    }
                                    this.totalSamples += decodedSamples.length;
                                    const minSamples = SAMPLE_RATE * MIN_AUDIO_DURATION;
                                    if (!this.playing && this.queue.length >= minSamples) {
                                        this.startPlaying();
                                    }
                                } else {
                                    log('Нет декодированных данных', 'warning');
                                }
                            },

                            startPlaying: function () {
                                if (this.playing || this.queue.length === 0) return;
                                this.playing = true;
                                const minPlaySamples = Math.min(this.queue.length, SAMPLE_RATE);
                                const currentSamples = this.queue.splice(0, minPlaySamples);
                                const audioBuffer = audioContext.createBuffer(CHANNELS, currentSamples.length, SAMPLE_RATE);
                                audioBuffer.copyToChannel(new Float32Array(currentSamples), 0);
                                this.source = audioContext.createBufferSource();
                                this.source.buffer = audioBuffer;
                                const gainNode = audioContext.createGain();
                                const fadeDuration = 0.02;
                                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                                gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + fadeDuration);
                                const duration = audioBuffer.duration;
                                if (duration > fadeDuration * 2) {
                                    gainNode.gain.setValueAtTime(1, audioContext.currentTime + duration - fadeDuration);
                                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);
                                }
                                this.source.connect(gainNode);
                                gainNode.connect(audioContext.destination);
                                this.lastPlayTime = audioContext.currentTime;
                                log(`Воспроизведение ${currentSamples.length} сэмплов (~${(currentSamples.length / SAMPLE_RATE).toFixed(2)} с)`, 'info');
                                this.source.onended = () => {
                                    this.source = null;
                                    this.playing = false;
                                    setTimeout(() => {
                                        if (this.queue.length > 0) {
                                            this.startPlaying();
                                        } else if (audioBufferQueue.length > 0) {
                                            const frames = [...audioBufferQueue];
                                            audioBufferQueue = [];
                                            this.decodeOpusFrames(frames);
                                        } else if (this.endOfStream) {
                                            log("Воспроизведение завершено", 'info');
                                            isAudioPlaying = false;
                                            this.endOfStream = false;
                                            streamingContext = null;
                                        } else {
                                            setTimeout(() => {
                                                if (this.queue.length === 0 && audioBufferQueue.length > 0) {
                                                    const frames = [...audioBufferQueue];
                                                    audioBufferQueue = [];
                                                    this.decodeOpusFrames(frames);
                                                } else if (this.queue.length === 0 && audioBufferQueue.length === 0) {
                                                    log("Воспроизведение завершено (таймаут)", 'info');
                                                    isAudioPlaying = false;
                                                    streamingContext = null;
                                                }
                                            }, 500);
                                        }
                                    }, 10);
                                };
                                this.source.start();
                            }
                        };
                    }

                    const frames = [...audioBufferQueue];
                    audioBufferQueue = [];
                    await streamingContext.decodeOpusFrames(frames);

                } catch (error) {
                    log(`Ошибка воспроизведения: ${error.message}`, 'error');
                    isAudioPlaying = false;
                    streamingContext = null;
                }
            };

            initDecoderAndPlay();
        }

        function convertInt16ToFloat32(int16Data) {
            const float32Data = new Float32Array(int16Data.length);
            for (let i = 0; i < int16Data.length; i++) {
                float32Data[i] = int16Data[i] / (int16Data[i] < 0 ? 0x8000 : 0x7FFF);
            }
            return float32Data;
        }

        async function initOpusDecoder() {
            if (opusDecoder) return opusDecoder;
            try {
                if (typeof window.ModuleInstance === 'undefined') {
                    if (typeof Module !== 'undefined') {
                        window.ModuleInstance = Module;
                        log('Используется глобальный Module как ModuleInstance', 'info');
                    } else {
                        throw new Error('Библиотека Opus не загружена');
                    }
                }

                const mod = window.ModuleInstance;
                opusDecoder = {
                    channels: CHANNELS,
                    rate: SAMPLE_RATE,
                    frameSize: FRAME_SIZE,
                    module: mod,
                    decoderPtr: null,

                    init: function () {
                        if (this.decoderPtr) return true;
                        const decoderSize = mod._opus_decoder_get_size(this.channels);
                        log(`Размер декодера Opus: ${decoderSize} байт`, 'debug');
                        this.decoderPtr = mod._malloc(decoderSize);
                        if (!this.decoderPtr) {
                            throw new Error("Не удалось выделить память для декодера");
                        }
                        const err = mod._opus_decoder_init(this.decoderPtr, this.rate, this.channels);
                        if (err < 0) {
                            this.destroy();
                            throw new Error(`Инициализация декодера Opus не удалась: ${err}`);
                        }
                        log("Декодер Opus инициализирован", 'success');
                        return true;
                    },
                    destroy: function () {
                        if (this.decoderPtr) {
                            this.module._free(this.decoderPtr);
                            this.decoderPtr = null;
                        }
                    },
                    decode: function (opusData) {
                        if (!this.decoderPtr) {
                            if (!this.init()) {
                                throw new Error("Декодер не инициализирован и не может быть инициализирован");
                            }
                        }
                        try {
                            const mod = this.module;
                            const opusPtr = mod._malloc(opusData.length);
                            mod.HEAPU8.set(opusData, opusPtr);
                            const pcmPtr = mod._malloc(this.frameSize * 2);
                            const decodedSamples = mod._opus_decode(
                                this.decoderPtr,
                                opusPtr,
                                opusData.length,
                                pcmPtr,
                                this.frameSize,
                                0
                            );
                            if (decodedSamples < 0) {
                                mod._free(opusPtr);
                                mod._free(pcmPtr);
                                throw new Error(`Декодирование Opus не удалось: ${decodedSamples}`);
                            }
                            const decodedData = new Int16Array(decodedSamples);
                            for (let i = 0; i < decodedSamples; i++) {
                                decodedData[i] = mod.HEAP16[(pcmPtr >> 1) + i];
                            }
                            mod._free(opusPtr);
                            mod._free(pcmPtr);
                            return decodedData;
                        } catch (error) {
                            log(`Ошибка декодирования Opus: ${error.message}`, 'error');
                            return new Int16Array(0);
                        }
                    }
                };
                if (!opusDecoder.init()) {
                    throw new Error("Инициализация декодера Opus не удалась");
                }
                return opusDecoder;
            } catch (error) {
                log(`Инициализация декодера Opus не удалась: ${error.message}`, 'error');
                opusDecoder = null;
                throw error;
            }
        }

        async function initAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 16000,
                        channelCount: 1
                    }
                });
                log('Доступ к микрофону получен', 'success');
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000,
                    latencyHint: 'interactive'
                });
                const source = audioContext.createMediaStreamSource(stream);
                const audioTracks = stream.getAudioTracks();
                if (audioTracks.length > 0) {
                    const track = audioTracks[0];
                    const settings = track.getSettings();
                    log(`Реальные настройки микрофона - частота дискретизации: ${settings.sampleRate || 'неизвестно'} Гц, количество каналов: ${settings.channelCount || 'неизвестно'}`, 'info');
                }
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);
                try {
                    mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'audio/webm;codecs=opus',
                        audioBitsPerSecond: 16000
                    });
                    log('MediaRecorder инициализирован (используется кодирование Opus)', 'success');
                    log(`Выбранный формат кодирования: ${mediaRecorder.mimeType}`, 'info');
                } catch (e1) {
                    try {
                        mediaRecorder = new MediaRecorder(stream, {
                            mimeType: 'audio/webm',
                            audioBitsPerSecond: 16000
                        });
                        log('MediaRecorder инициализирован (используется стандартное кодирование WebM, Opus не поддерживается)', 'warning');
                        log(`Выбранный формат кодирования: ${mediaRecorder.mimeType}`, 'info');
                    } catch (e2) {
                        try {
                            mediaRecorder = new MediaRecorder(stream, {
                                mimeType: 'audio/ogg;codecs=opus',
                                audioBitsPerSecond: 16000
                            });
                            log('MediaRecorder инициализирован (используется OGG+Opus кодирование)', 'warning');
                            log(`Выбранный формат кодирования: ${mediaRecorder.mimeType}`, 'info');
                        } catch (e3) {
                            mediaRecorder = new MediaRecorder(stream);
                            log(`MediaRecorder инициализирован (используется кодирование по умолчанию: ${mediaRecorder.mimeType})`, 'warning');
                        }
                    }
                }
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                mediaRecorder.onstop = async () => {
                    if (visualizationRequest) {
                        cancelAnimationFrame(visualizationRequest);
                        visualizationRequest = null;
                    }
                    log(`Запись завершена, количество собранных аудио блоков: ${audioChunks.length}`, 'info');
                    if (audioChunks.length === 0) {
                        log('Предупреждение: не собрано никаких аудио данных, проверьте, работает ли микрофон', 'error');
                        return;
                    }
                    const blob = new Blob(audioChunks, { type: audioChunks[0].type });
                    log(`Аудио Blob создан, MIME тип: ${audioChunks[0].type}, размер: ${(blob.size / 1024).toFixed(2)} КБ`, 'info');
                    const chunks = [...audioChunks];
                    audioChunks = [];
                    try {
                        const arrayBuffer = await blob.arrayBuffer();
                        const uint8Array = new Uint8Array(arrayBuffer);
                        log(`Преобразовано в Uint8Array, готово к отправке, размер: ${(arrayBuffer.byteLength / 1024).toFixed(2)} КБ`, 'info');
                        if (!websocket) {
                            log('Ошибка: соединение WebSocket отсутствует', 'error');
                            return;
                        }
                        if (websocket.readyState !== WebSocket.OPEN) {
                            log(`Ошибка: соединение WebSocket не открыто, текущее состояние: ${websocket.readyState}`, 'error');
                            return;
                        }
                        try {
                            await new Promise(resolve => setTimeout(resolve, 50));
                            const opusData = extractOpusFrames(uint8Array);
                            log(`Извлечены данные Opus, размер: ${(opusData.byteLength / 1024).toFixed(2)} КБ`, 'info');
                            websocket.send(opusData);
                            log(`Отправлены аудио данные Opus: ${(opusData.byteLength / 1024).toFixed(2)} КБ`, 'success');
                        } catch (error) {
                            log(`Ошибка отправки аудио данных: ${error.message}`, 'error');
                            try {
                                log('Попытка отправить в кодировке base64...', 'info');
                                const base64Data = arrayBufferToBase64(arrayBuffer);
                                const audioDataMessage = {
                                    type: 'audio',
                                    action: 'data',
                                    format: 'opus',
                                    sample_rate: 16000,
                                    channels: 1,
                                    mime_type: chunks[0].type,
                                    encoding: 'base64',
                                    data: base64Data
                                };
                                websocket.send(JSON.stringify(audioDataMessage));
                                log(`Отправлены аудио данные в кодировке base64: ${(arrayBuffer.byteLength / 1024).toFixed(2)} КБ`, 'warning');
                            } catch (base64Error) {
                                log(`Все способы отправки данных не удалась: ${base64Error.message}`, 'error');
                            }
                        }
                    } catch (error) {
                        log(`Ошибка обработки записанных данных: ${error.message}`, 'error');
                    }
                };
                try {
                    if (typeof window.ModuleInstance === 'undefined') {
                        throw new Error('Библиотека Opus не загружена, объект ModuleInstance не существует');
                    }
                    if (typeof window.ModuleInstance._opus_decoder_get_size === 'function') {
                        const testSize = window.ModuleInstance._opus_decoder_get_size(1);
                        log(`Тест декодера Opus прошёл успешно, размер декодера: ${testSize} байт`, 'success');
                    } else {
                        throw new Error('Функции декодирования Opus не найдены');
                    }
                } catch (err) {
                    log(`Предупреждение при инициализации декодера Opus: ${err.message}, будет повторено при необходимости`, 'warning');
                }
                log('Инициализация аудио системы завершена', 'success');
                return true;
            } catch (error) {
                log(`Ошибка инициализации аудио: ${error.message}`, 'error');
                return false;
            }
        }

        function startRecording() {
            if (isRecording) return;
            try {
                log('Пожалуйста, запишите минимум 1-2 секунды аудио, чтобы гарантировать сбор достаточных данных', 'info');
                const serverUrl = serverUrlInput.value.trim();
                let isXiaozhiNative = false;
                if (serverUrl.includes('xiaozhi') || serverUrl.includes('localhost') || serverUrl.includes('127.0.0.1')) {
                    isXiaozhiNative = true;
                    log('Обнаружен родной сервер XiaoZhi, используется стандартный протокол listen', 'info');
                }
                startDirectRecording();
            } catch (error) {
                log(`Ошибка запуска записи: ${error.message}`, 'error');
            }
        }

        function stopRecording() {
            if (!isRecording) return;
            try {
                stopDirectRecording();
            } catch (error) {
                log(`Ошибка остановки записи: ${error.message}`, 'error');
            }
        }

        async function connectToServer() {
            const url = serverUrlInput.value.trim();
            if (url === '') return;
            try {
                const config = getConfig();
                if (!validateConfig(config)) {
                    return;
                }
                if (!url.startsWith('ws://') && !url.startsWith('wss://')) {
                    log('Ошибка формата URL, должен начинаться с ws:// или wss://', 'error');
                    return;
                }
                log('Проверка состояния OTA...', 'info');
                const otaUrl = document.getElementById('otaUrl').value.trim();
                localStorage.setItem('otaUrl', otaUrl);
                localStorage.setItem('wsUrl', url);
                try {
                    const otaResponse = await fetch(otaUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Device-Id': config.deviceId,
                            'Client-Id': config.clientId
                        },
                        body: JSON.stringify({
                            "version": 0,
                            "uuid": "",
                            "application": {
                                "name": "xiaozhi-web-test",
                                "version": "1.0.0",
                                "compile_time": "2025-04-16 10:00:00",
                                "idf_version": "4.4.3",
                                "elf_sha256": "1234567890abcdef1234567890abcdef1234567890abcdef"
                            },
                            "ota": {
                                "label": "xiaozhi-web-test",
                            },
                            "board": {
                                "type": "xiaozhi-web-test",
                                "ssid": "xiaozhi-web-test",
                                "rssi": 0,
                                "channel": 0,
                                "ip": "192.168.1.1",
                                "mac": config.deviceMac
                            },
                            "flash_size": 0,
                            "minimum_free_heap_size": 0,
                            "mac_address": config.deviceMac,
                            "chip_model_name": "",
                            "chip_info": {
                                "model": 0,
                                "cores": 0,
                                "revision": 0,
                                "features": 0
                            },
                            "partition_table": [
                                {
                                    "label": "",
                                    "type": 0,
                                    "subtype": 0,
                                    "address": 0,
                                    "size": 0
                                }
                            ]
                        })
                    });
                    if (!otaResponse.ok) {
                        throw new Error(`Проверка OTA не удалась: ${otaResponse.status} ${otaResponse.statusText}`);
                    }
                    const otaResult = await otaResponse.json();
                    log(`Результат проверки OTA: ${JSON.stringify(otaResult)}`, 'info');
                    log('Проверка OTA пройдена, начинается подключение к WebSocket...', 'success');
                    document.getElementById('otaStatus').textContent = 'ota подключено';
                    document.getElementById('otaStatus').style.color = 'green';
                } catch (error) {
                    log(`Ошибка проверки OTA: ${error.message}`, 'error');
                    document.getElementById('otaStatus').textContent = 'ota не подключено';
                    document.getElementById('otaStatus').style.color = 'red';
                }
                let connUrl = new URL(url);
                connUrl.searchParams.append('device-id', config.deviceId);
                connUrl.searchParams.append('client-id', config.clientId);
                log(`Подключение к: ${connUrl.toString()}`, 'info');
                websocket = new WebSocket(connUrl.toString());
                websocket.binaryType = 'arraybuffer';
                websocket.onopen = async () => {
                    log(`Подключено к серверу: ${url}`, 'success');
                    connectionStatus.textContent = 'ws подключено';
                    connectionStatus.style.color = 'green';
                    await sendHelloMessage();
                    connectButton.textContent = 'Отключиться';
                    connectButton.removeEventListener('click', connectToServer);
                    connectButton.addEventListener('click', disconnectFromServer);
                    messageInput.disabled = false;
                    sendTextButton.disabled = false;
                    const audioInitialized = await initAudio();
                    if (audioInitialized) {
                        recordButton.disabled = false;
                    }
                };
                websocket.onclose = () => {
                    log('Подключение разорвано', 'info');
                    connectionStatus.textContent = 'ws отключено';
                    connectionStatus.style.color = 'red';
                    connectButton.textContent = 'Подключиться';
                    connectButton.removeEventListener('click', disconnectFromServer);
                    connectButton.addEventListener('click', connectToServer);
                    messageInput.disabled = true;
                    sendTextButton.disabled = true;
                    recordButton.disabled = true;
                    stopButton.disabled = true;
                };
                websocket.onerror = (error) => {
                    log(`Ошибка WebSocket: ${error.message || 'неизвестная ошибка'}`, 'error');
                    connectionStatus.textContent = 'ws не подключено';
                    connectionStatus.style.color = 'red';
                };
                websocket.onmessage = function (event) {
                    try {
                        if (typeof event.data === 'string') {
                            const message = JSON.parse(event.data);
                            if (message.type === 'hello') {
                                log(`Ответ сервера: ${JSON.stringify(message, null, 2)}`, 'success');
                            } else if (message.type === 'tts') {
                                if (message.state === 'start') {
                                    log('Сервер начал отправку голоса', 'info');
                                } else if (message.state === 'sentence_start') {
                                    log(`Сервер отправляет фрагмент голоса: ${message.text}`, 'info');
                                    if (message.text) {
                                        addMessage(message.text);
                                    }
                                } else if (message.state === 'sentence_end') {
                                    log(`Конец фрагмента голоса: ${message.text}`, 'info');
                                } else if (message.state === 'stop') {
                                    log('Передача голоса сервером завершена', 'info');
                                    if (recordButton.disabled) {
                                        recordButton.disabled = false;
                                        recordButton.textContent = 'Начать запись';
                                        recordButton.classList.remove('recording');
                                    }
                                }
                            } else if (message.type === 'audio') {
                                log(`Получено управляющее сообщение аудио: ${JSON.stringify(message)}`, 'info');
                            } else if (message.type === 'stt') {
                                log(`Результат распознавания: ${message.text}`, 'info');
                                addMessage(`[Распознавание речи] ${message.text}`, true);
                            } else if (message.type === 'llm') {
                                log(`Ответ большой модели: ${message.text}`, 'info');
                                if (message.text && message.text !== '😊') {
                                    addMessage(message.text);
                                }
                            } else if (message.type === 'mcp') {
                                const payload = message.payload || {};
                                log(`Сервер отправил: ${JSON.stringify(message)}`, 'info');
                                if (payload) {
                                    if(payload.method === 'tools/list'){
                                        const replay_message = JSON.stringify({"session_id":"","type":"mcp","payload":{"jsonrpc":"2.0","id":2,"result":{"tools":[{"name":"self.get_device_status","description":"Provides the real-time information of the device, including the current status of the audio speaker, screen, battery, network, etc.\nUse this tool for: \n1. Answering questions about current condition (e.g. what is the current volume of the audio speaker?)\n2. As the first step to control the device (e.g. turn up / down the volume of the audio speaker, etc.)","inputSchema":{"type":"object","properties":{}}},{"name":"self.audio_speaker.set_volume","description":"Set the volume of the audio speaker. If the current volume is unknown, you must call `self.get_device_status` tool first and then call this tool.","inputSchema":{"type":"object","properties":{"volume":{"type":"integer","minimum":0,"maximum":100}},"required":["volume"]}},{"name":"self.screen.set_brightness","description":"Set the brightness of the screen.","inputSchema":{"type":"object","properties":{"brightness":{"type":"integer","minimum":0,"maximum":100}},"required":["brightness"]}},{"name":"self.screen.set_theme","description":"Set the theme of the screen. The theme can be 'light' or 'dark'.","inputSchema":{"type":"object","properties":{"theme":{"type":"string"}},"required":["theme"]}}]}}})
                                        websocket.send(replay_message);
                                        log(`Ответить на сообщение MCP: ${replay_message}`, 'info');
                                    } else if(payload.method === 'tools/call'){
                                        const replay_message = JSON.stringify({"session_id":"9f261599","type":"mcp","payload":{"jsonrpc":"2.0","id": payload.id,"result":{"content":[{"type":"text","text":"true"}],"isError":false}}})
                                        websocket.send(replay_message);
                                        log(`Ответить на сообщение MCP: ${replay_message}`, 'info');
                                    }
                                }
                            } else {
                                log(`Неизвестный тип сообщения: ${message.type}`, 'info');
                                addMessage(JSON.stringify(message, null, 2));
                            }
                        } else {
                            handleBinaryMessage(event.data);
                        }
                    } catch (error) {
                        log(`Ошибка обработки сообщения WebSocket: ${error.message}`, 'error');
                        if (typeof event.data === 'string') {
                            addMessage(event.data);
                        }
                    }
                };
                connectionStatus.textContent = 'ws не подключено';
                connectionStatus.style.color = 'orange';
            } catch (error) {
                log(`Ошибка подключения: ${error.message}`, 'error');
                connectionStatus.textContent = 'ws не подключено';
            }
        }

        async function sendHelloMessage() {
            if (!websocket || websocket.readyState !== WebSocket.OPEN) return;
            try {
                const config = getConfig();
                const helloMessage = {
                    type: 'hello',
                    device_id: config.deviceId,
                    device_name: config.device_name,
                    device_mac: config.deviceMac,
                    token: config.token,
                    features: {
                        mcp: true
                    }
                };
                log('Отправка сообщения приветствия hello', 'info');
                websocket.send(JSON.stringify(helloMessage));
                return new Promise(resolve => {
                    const timeout = setTimeout(() => {
                        log('Таймаут ожидания ответа hello', 'error');
                        log('Подсказка: попробуйте нажать кнопку "Проверить аутентификацию" для диагностики подключения', 'info');
                        resolve(false);
                    }, 5000);
                    const onMessageHandler = (event) => {
                        try {
                            const response = JSON.parse(event.data);
                            if (response.type === 'hello' && response.session_id) {
                                log(`Успешное рукопожатие с сервером, ID сессии: ${response.session_id}`, 'success');
                                clearTimeout(timeout);
                                websocket.removeEventListener('message', onMessageHandler);
                                resolve(true);
                            }
                        } catch (e) {
                        }
                    };
                    websocket.addEventListener('message', onMessageHandler);
                });
            } catch (error) {
                log(`Ошибка отправки сообщения hello: ${error.message}`, 'error');
                return false;
            }
        }

        function disconnectFromServer() {
            if (!websocket) return;
            websocket.close();
            stopRecording();
        }

        function sendTextMessage() {
            const message = messageInput.value.trim();
            if (message === '' || !websocket || websocket.readyState !== WebSocket.OPEN) return;
            audioBufferQueue = [];
            isAudioBuffering = false;
            isAudioPlaying = false;
            try {
                const listenMessage = {
                    type: 'listen',
                    mode: 'manual',
                    state: 'detect',
                    text: message
                };
                websocket.send(JSON.stringify(listenMessage));
                addMessage(message, true);
                log(`Отправлено текстовое сообщение: ${message}`, 'info');
                messageInput.value = '';
            } catch (error) {
                log(`Ошибка отправки сообщения: ${error.message}`, 'error');
            }
        }

        function generateRandomMac() {
            const hexDigits = '0123456789ABCDEF';
            let mac = '';
            for (let i = 0; i < 6; i++) {
                if (i > 0) mac += ':';
                for (let j = 0; j < 2; j++) {
                    mac += hexDigits.charAt(Math.floor(Math.random() * 16));
                }
            }
            return mac;
        }

        function initEventListeners() {
            connectButton.addEventListener('click', connectToServer);
            document.getElementById('authTestButton').addEventListener('click', testAuthentication);
            const toggleButton = document.getElementById('toggleConfig');
            const configPanel = document.getElementById('configPanel');
            const deviceMacInput = document.getElementById('deviceMac');
            const clientIdInput = document.getElementById('clientId');
            const displayMac = document.getElementById('displayMac');
            const displayClient = document.getElementById('displayClient');
            let savedMac = localStorage.getItem('deviceMac');
            if (!savedMac) {
                savedMac = generateRandomMac();
                localStorage.setItem('deviceMac', savedMac);
            }
            deviceMacInput.value = savedMac;
            displayMac.textContent = savedMac;
            function updateDisplayValues() {
                const newMac = deviceMacInput.value;
                displayMac.textContent = newMac;
                displayClient.textContent = clientIdInput.value;
                localStorage.setItem('deviceMac', newMac);
            }
            deviceMacInput.addEventListener('input', updateDisplayValues);
            clientIdInput.addEventListener('input', updateDisplayValues);
            updateDisplayValues();
            const savedOtaUrl = localStorage.getItem('otaUrl');
            if (savedOtaUrl) {
                document.getElementById('otaUrl').value = savedOtaUrl;
            }
            const savedWsUrl = localStorage.getItem('wsUrl');
            if (savedWsUrl) {
                document.getElementById('serverUrl').value = savedWsUrl;
            }
            toggleButton.addEventListener('click', () => {
                const isExpanded = configPanel.classList.contains('expanded');
                configPanel.classList.toggle('expanded');
                toggleButton.textContent = isExpanded ? 'Редактировать' : 'Свернуть';
            });
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(`${tab.dataset.tab}Tab`).classList.add('active');
                });
            });
            sendTextButton.addEventListener('click', sendTextMessage);
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendTextMessage();
            });
            recordButton.addEventListener('click', () => {
                if (isRecording) {
                    stopRecording();
                } else {
                    startRecording();
                }
            });
            window.addEventListener('resize', initVisualizer);
        }

        async function testAuthentication() {
            log('Начало теста аутентификации...', 'info');
            const config = getConfig();
            log('-------- Проверка конфигурации аутентификации сервера --------', 'info');
            log('Пожалуйста, подтвердите конфигурацию auth в config.yaml:', 'info');
            log('1. server.auth.enabled установлен в false или сервер правильно настроен для аутентификации', 'info');
            log('2. Если аутентификация включена, убедитесь, что используется правильный токен', 'info');
            log(`3. Или добавьте MAC-адрес тестового устройства в allowed_devices: ${config.deviceMac}`, 'info');
            const serverUrl = serverUrlInput.value.trim();
            if (!serverUrl) {
                log('Введите адрес сервера', 'error');
                return;
            }
            try {
                log('Тест 1: Попытка подключения без параметров...', 'info');
                const ws1 = new WebSocket(serverUrl);
                ws1.onopen = () => {
                    log('Тест 1 успешен: подключение без параметров возможно, возможно, сервер не включил аутентификацию', 'success');
                    ws1.close();
                };
                ws1.onerror = (error) => {
                    log('Тест 1 не удался: подключение без параметров отклонено, возможно, сервер включил аутентификацию', 'error');
                };
                setTimeout(() => {
                    if (ws1.readyState === WebSocket.CONNECTING || ws1.readyState === WebSocket.OPEN) {
                        ws1.close();
                    }
                }, 5000);
            } catch (error) {
                log(`Ошибка теста 1: ${error.message}`, 'error');
            }
            setTimeout(async () => {
                try {
                    log('Тест 2: Попытка подключения с параметром токена...', 'info');
                    let url = new URL(serverUrl);
                    url.searchParams.append('token', config.token);
                    url.searchParams.append('device_id', config.deviceId);
                    url.searchParams.append('device_mac', config.deviceMac);
                    const ws2 = new WebSocket(url.toString());
                    ws2.onopen = () => {
                        log('Тест 2 успешен: подключение с параметром токена возможно', 'success');
                        const helloMsg = {
                            type: 'hello',
                            device_id: config.deviceId,
                            device_mac: config.deviceMac,
                            token: config.token
                        };
                        ws2.send(JSON.stringify(helloMsg));
                        log('Отправлено тестовое сообщение hello', 'info');
                        ws2.onmessage = (event) => {
                            try {
                                const response = JSON.parse(event.data);
                                if (response.type === 'hello' && response.session_id) {
                                    log(`Тест полностью успешен! Получен ответ hello, ID сессии: ${response.session_id}`, 'success');
                                    ws2.close();
                                }
                            } catch (e) {
                                log(`Получен не-JSON ответ: ${event.data}`, 'info');
                            }
                        };
                        setTimeout(() => ws2.close(), 5000);
                    };
                    ws2.onerror = (error) => {
                        log('Тест 2 не удался: подключение с параметром токена отклонено', 'error');
                        log('Проверьте правильность токена или принимает ли сервер параметры аутентификации в URL', 'error');
                    };
                } catch (error) {
                    log(`Ошибка теста 2: ${error.message}`, 'error');
                }
            }, 6000);
            log('Тест аутентификации запущен, проверьте результаты теста...', 'info');
        }

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        let opusEncoder = null;
        function initOpusEncoder() {
            try {
                if (opusEncoder) {
                    return true;
                }
                if (!window.ModuleInstance) {
                    log('Невозможно создать кодировщик Opus: ModuleInstance недоступен', 'error');
                    return false;
                }
                const mod = window.ModuleInstance;
                const sampleRate = 16000;
                const channels = 1;
                const application = 2048;
                opusEncoder = {
                    channels: channels,
                    sampleRate: sampleRate,
                    frameSize: 960,
                    maxPacketSize: 4000,
                    module: mod,
                    init: function () {
                        try {
                            const encoderSize = mod._opus_encoder_get_size(this.channels);
                            log(`Размер кодировщика Opus: ${encoderSize} байт`, 'info');
                            this.encoderPtr = mod._malloc(encoderSize);
                            if (!this.encoderPtr) {
                                throw new Error("Невозможно выделить память для кодировщика");
                            }
                            const err = mod._opus_encoder_init(
                                this.encoderPtr,
                                this.sampleRate,
                                this.channels,
                                application
                            );
                            if (err < 0) {
                                throw new Error(`Инициализация кодировщика Opus не удалась: ${err}`);
                            }
                            mod._opus_encoder_ctl(this.encoderPtr, 4002, 16000);
                            mod._opus_encoder_ctl(this.encoderPtr, 4010, 5);
                            mod._opus_encoder_ctl(this.encoderPtr, 4016, 1);
                            log("Инициализация кодировщика Opus успешна", 'success');
                            return true;
                        } catch (error) {
                            if (this.encoderPtr) {
                                mod._free(this.encoderPtr);
                                this.encoderPtr = null;
                            }
                            log(`Инициализация кодировщика Opus не удалась: ${error.message}`, 'error');
                            return false;
                        }
                    },
                    encode: function (pcmData) {
                        if (!this.encoderPtr) {
                            if (!this.init()) {
                                return null;
                            }
                        }
                        try {
                            const mod = this.module;
                            const pcmPtr = mod._malloc(pcmData.length * 2);
                            for (let i = 0; i < pcmData.length; i++) {
                                mod.HEAP16[(pcmPtr >> 1) + i] = pcmData[i];
                            }
                            const outPtr = mod._malloc(this.maxPacketSize);
                            const encodedLen = mod._opus_encode(
                                this.encoderPtr,
                                pcmPtr,
                                this.frameSize,
                                outPtr,
                                this.maxPacketSize
                            );
                            if (encodedLen < 0) {
                                throw new Error(`Кодирование Opus не удалось: ${encodedLen}`);
                            }
                            const opusData = new Uint8Array(encodedLen);
                            for (let i = 0; i < encodedLen; i++) {
                                opusData[i] = mod.HEAPU8[outPtr + i];
                            }
                            mod._free(pcmPtr);
                            mod._free(outPtr);
                            return opusData;
                        } catch (error) {
                            log(`Ошибка кодирования Opus: ${error.message}`, 'error');
                            return null;
                        }
                    },
                    destroy: function () {
                        if (this.encoderPtr) {
                            this.module._free(this.encoderPtr);
                            this.encoderPtr = null;
                        }
                    }
                };
                const result = opusEncoder.init();
                return result;
            } catch (error) {
                log(`Создание кодировщика Opus не удалось: ${error.message}`, 'error');
                return false;
            }
        }

        function initApp() {
            initVisualizer();
            initEventListeners();
            checkOpusLoaded();
            initOpusEncoder();
            log('Предварительная загрузка декодера Opus...', 'info');
            initOpusDecoder().then(() => {
                log('Предварительная загрузка декодера Opus успешна', 'success');
            }).catch(error => {
                log(`Предварительная загрузка декодера Opus не удалась: ${error.message}, будет повторена при необходимости`, 'warning');
            });
        }

        const audioProcessorCode = `
            class AudioRecorderProcessor extends AudioWorkletProcessor {
                constructor() {
                    super();
                    this.buffers = [];
                    this.frameSize = 960;
                    this.buffer = new Int16Array(this.frameSize);
                    this.bufferIndex = 0;
                    this.isRecording = false;
                    this.port.onmessage = (event) => {
                        if (event.data.command === 'start') {
                            this.isRecording = true;
                            this.port.postMessage({ type: 'status', status: 'started' });
                        } else if (event.data.command === 'stop') {
                            this.isRecording = false;
                            if (this.bufferIndex > 0) {
                                const finalBuffer = this.buffer.slice(0, this.bufferIndex);
                                this.port.postMessage({
                                    type: 'buffer',
                                    buffer: finalBuffer
                                });
                                this.bufferIndex = 0;
                            }
                            this.port.postMessage({ type: 'status', status: 'stopped' });
                        }
                    };
                }
                process(inputs, outputs, parameters) {
                    if (!this.isRecording) return true;
                    const input = inputs[0][0];
                    if (!input) return true;
                    for (let i = 0; i < input.length; i++) {
                        if (this.bufferIndex >= this.frameSize) {
                            this.port.postMessage({
                                type: 'buffer',
                                buffer: this.buffer.slice(0)
                            });
                            this.bufferIndex = 0;
                        }
                        this.buffer[this.bufferIndex++] = Math.max(-32768, Math.min(32767, Math.floor(input[i] * 32767)));
                    }
                    return true;
                }
            }
            registerProcessor('audio-recorder-processor', AudioRecorderProcessor);
        `;

        async function createAudioProcessor() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000,
                    latencyHint: 'interactive'
                });
            }
            try {
                if (audioContext.audioWorklet) {
                    const blob = new Blob([audioProcessorCode], { type: 'application/javascript' });
                    const url = URL.createObjectURL(blob);
                    await audioContext.audioWorklet.addModule(url);
                    URL.revokeObjectURL(url);
                    const audioProcessor = new AudioWorkletNode(audioContext, 'audio-recorder-processor');
                    audioProcessor.port.onmessage = (event) => {
                        if (event.data.type === 'buffer') {
                            processPCMBuffer(event.data.buffer);
                        }
                    };
                    log('Использование AudioWorklet для обработки аудио', 'success');
                    return { node: audioProcessor, type: 'worklet' };
                } else {
                    log('AudioWorklet недоступен, использование ScriptProcessorNode как резервный вариант', 'warning');
                    const frameSize = 4096;
                    const scriptProcessor = audioContext.createScriptProcessor(frameSize, 1, 1);
                    scriptProcessor.onaudioprocess = (event) => {
                        if (!isRecording) return;
                        const input = event.inputBuffer.getChannelData(0);
                        const buffer = new Int16Array(input.length);
                        for (let i = 0; i < input.length; i++) {
                            buffer[i] = Math.max(-32768, Math.min(32767, Math.floor(input[i] * 32767)));
                        }
                        processPCMBuffer(buffer);
                    };
                    const silent = audioContext.createGain();
                    silent.gain.value = 0;
                    scriptProcessor.connect(silent);
                    silent.connect(audioContext.destination);
                    return { node: scriptProcessor, type: 'processor' };
                }
            } catch (error) {
                log(`Создание процессора аудио не удалось: ${error.message}, попытка резервного варианта`, 'error');
                try {
                    const frameSize = 4096;
                    const scriptProcessor = audioContext.createScriptProcessor(frameSize, 1, 1);
                    scriptProcessor.onaudioprocess = (event) => {
                        if (!isRecording) return;
                        const input = event.inputBuffer.getChannelData(0);
                        const buffer = new Int16Array(input.length);
                        for (let i = 0; i < input.length; i++) {
                            buffer[i] = Math.max(-32768, Math.min(32767, Math.floor(input[i] * 32767)));
                        }
                        processPCMBuffer(buffer);
                    };
                    const silent = audioContext.createGain();
                    silent.gain.value = 0;
                    scriptProcessor.connect(silent);
                    silent.connect(audioContext.destination);
                    log('Использование ScriptProcessorNode как резервный вариант прошло успешно', 'warning');
                    return { node: scriptProcessor, type: 'processor' };
                } catch (fallbackError) {
                    log(`Резервный вариант также не удался: ${fallbackError.message}`, 'error');
                    return null;
                }
            }
        }

        let audioProcessor = null;
        let audioProcessorType = null;
        let audioSource = null;

        let pcmDataBuffer = new Int16Array();
        function processPCMBuffer(buffer) {
            if (!isRecording) return;
            const newBuffer = new Int16Array(pcmDataBuffer.length + buffer.length);
            newBuffer.set(pcmDataBuffer);
            newBuffer.set(buffer, pcmDataBuffer.length);
            pcmDataBuffer = newBuffer;
            const samplesPerFrame = 960;
            while (pcmDataBuffer.length >= samplesPerFrame) {
                const frameData = pcmDataBuffer.slice(0, samplesPerFrame);
                pcmDataBuffer = pcmDataBuffer.slice(samplesPerFrame);
                encodeAndSendOpus(frameData);
            }
        }

        function encodeAndSendOpus(pcmData = null) {
            if (!opusEncoder) {
                log('Кодировщик Opus не инициализирован', 'error');
                return;
            }
            try {
                if (pcmData) {
                    const opusData = opusEncoder.encode(pcmData);
                    if (opusData && opusData.length > 0) {
                        audioBuffers.push(opusData.buffer);
                        totalAudioSize += opusData.length;
                        if (websocket && websocket.readyState === WebSocket.OPEN) {
                            try {
                                websocket.send(opusData.buffer);
                                log(`Отправлен фрейм Opus, размер: ${opusData.length} байт`, 'debug');
                            } catch (error) {
                                log(`Ошибка отправки WebSocket: ${error.message}`, 'error');
                            }
                        }
                    } else {
                        log('Кодирование Opus не удалось, нет возвращённых данных', 'error');
                    }
                } else {
                    if (pcmDataBuffer.length > 0) {
                        const samplesPerFrame = 960;
                        if (pcmDataBuffer.length < samplesPerFrame) {
                            const paddedBuffer = new Int16Array(samplesPerFrame);
                            paddedBuffer.set(pcmDataBuffer);
                            encodeAndSendOpus(paddedBuffer);
                        } else {
                            encodeAndSendOpus(pcmDataBuffer.slice(0, samplesPerFrame));
                        }
                        pcmDataBuffer = new Int16Array(0);
                    }
                }
            } catch (error) {
                log(`Ошибка кодирования Opus: ${error.message}`, 'error');
            }
        }

        async function startDirectRecording() {
            if (isRecording) return;
            try {
                if (!initOpusEncoder()) {
                    log('Невозможно начать запись: инициализация кодировщика Opus не удалась', 'error');
                    return;
                }
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 16000,
                        channelCount: 1
                    }
                });
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000,
                        latencyHint: 'interactive'
                    });
                }
                const processorResult = await createAudioProcessor();
                if (!processorResult) {
                    log('Невозможно создать процессор аудио', 'error');
                    return;
                }
                audioProcessor = processorResult.node;
                audioProcessorType = processorResult.type;
                audioSource = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                audioSource.connect(analyser);
                audioSource.connect(audioProcessor);
                pcmDataBuffer = new Int16Array();
                audioBuffers = [];
                totalAudioSize = 0;
                isRecording = true;
                if (audioProcessorType === 'worklet' && audioProcessor.port) {
                    audioProcessor.port.postMessage({ command: 'start' });
                }
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    const listenMessage = {
                        type: 'listen',
                        mode: 'manual',
                        state: 'start'
                    };
                    log(`Отправлено сообщение о начале записи: ${JSON.stringify(listenMessage)}`, 'info');
                    websocket.send(JSON.stringify(listenMessage));
                } else {
                    log('WebSocket не подключён, невозможно отправить сообщение о начале', 'error');
                    return false;
                }
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                drawVisualizer(dataArray);
                let recordingSeconds = 0;
                const recordingTimer = setInterval(() => {
                    recordingSeconds += 0.1;
                    recordButton.textContent = `Остановить запись ${recordingSeconds.toFixed(1)} сек`;
                }, 100);
                window.recordingTimer = recordingTimer;
                recordButton.classList.add('recording');
                recordButton.disabled = false;
                log('Начало прямой записи PCM', 'success');
                return true;
            } catch (error) {
                log(`Ошибка запуска прямой записи: ${error.message}`, 'error');
                isRecording = false;
                return false;
            }
        }

        function stopDirectRecording() {
            if (!isRecording) return;
            try {
                isRecording = false;
                if (audioProcessor) {
                    if (audioProcessorType === 'worklet' && audioProcessor.port) {
                        audioProcessor.port.postMessage({ command: 'stop' });
                    }
                    audioProcessor.disconnect();
                    audioProcessor = null;
                }
                if (audioSource) {
                    audioSource.disconnect();
                    audioSource = null;
                }
                if (visualizationRequest) {
                    cancelAnimationFrame(visualizationRequest);
                    visualizationRequest = null;
                }
                if (window.recordingTimer) {
                    clearInterval(window.recordingTimer);
                    window.recordingTimer = null;
                }
                encodeAndSendOpus();
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    const emptyOpusFrame = new Uint8Array(0);
                    websocket.send(emptyOpusFrame);
                    const stopMessage = {
                        type: 'listen',
                        mode: 'manual',
                        state: 'stop'
                    };
                    websocket.send(JSON.stringify(stopMessage));
                    log('Отправлен сигнал о прекращении записи', 'info');
                }
                recordButton.textContent = 'Начать запись';
                recordButton.classList.remove('recording');
                recordButton.disabled = false;
                log('Остановлена прямая запись PCM', 'success');
                return true;
            } catch (error) {
                log(`Ошибка остановки прямой записи: ${error.message}`, 'error');
                return false;
            }
        }

        async function handleBinaryMessage(data) {
            try {
                let arrayBuffer;
                if (data instanceof ArrayBuffer) {
                    arrayBuffer = data;
                    log(`Получены данные аудио в формате ArrayBuffer, размер: ${data.byteLength} байт`, 'debug');
                } else if (data instanceof Blob) {
                    arrayBuffer = await data.arrayBuffer();
                    log(`Получены данные аудио в формате Blob, размер: ${arrayBuffer.byteLength} байт`, 'debug');
                } else {
                    log(`Получены данные в неизвестном бинарном формате: ${typeof data}`, 'warning');
                    return;
                }
                const opusData = new Uint8Array(arrayBuffer);
                if (opusData.length > 0) {
                    audioBufferQueue.push(opusData);
                    if (audioBufferQueue.length === 1 && !isAudioBuffering && !isAudioPlaying) {
                        startAudioBuffering();
                    }
                } else {
                    log('Получен пустой кадр аудио данных, возможно, признак окончания', 'warning');
                    if (audioBufferQueue.length > 0 && !isAudioPlaying) {
                        playBufferedAudio();
                    }
                    if (isAudioPlaying && streamingContext) {
                        streamingContext.endOfStream = true;
                    }
                }
            } catch (error) {
                log(`Ошибка обработки бинарного сообщения: ${error.message}`, 'error');
            }
        }

        function getConfig() {
            const deviceMac = document.getElementById('deviceMac').value.trim();
            return {
                deviceId: deviceMac,
                deviceName: document.getElementById('deviceName').value.trim(),
                deviceMac: deviceMac,
                clientId: document.getElementById('clientId').value.trim(),
                token: document.getElementById('token').value.trim()
            };
        }

        function validateConfig(config) {
            if (!config.deviceMac) {
                log('MAC-адрес устройства не может быть пустым', 'error');
                return false;
            }
            if (!config.clientId) {
                log('ID клиента не может быть пустым', 'error');
                return false;
            }
            return true;
        }

        initApp();
    </script>
</body>
</html>